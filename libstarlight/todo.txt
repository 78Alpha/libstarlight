


roadmap to first release, in no particular order {
    - implement app:/ asset loading
    finish implementing OSK! {
        - make backspace and enter actually do something
        - abstract osk input actions into a separate object/class heirarchy
        - preview where applicable
        fix desync between cursor position, tap-cursor and display when a single word overflows a line
            (cursor doesn't wrap until the next word!?)
        polish!
        InputManager::OpenKeyboard
    }
    textbox widget
    - "draw proxy" UIElement (takes a std::function for draw operation)
    
    add license!! (MIT?)
    ADD README.MD PLS
} and some lesser priority things {
    add language config and atlas support
    maybe implement some way of "knocking out" and replacing metrics during runtime for theme switching
}

form system { framework done apart from some small api changes
    capabilities {
        updates, recieves events etc. as if it were a stackable Application
        priority level (modals etc.)
        can be stacked, reordered etc. via order shown
        can occlude independently on top and bottom screen, causing lower-ordered things on that screen to not even render
        can tell if it's the focused (topmost) form and use that to determine whether to accept button input
        
    }
    meaningful state change signals current Application to resort and rebuild draw list during next update
}


today's agenda {
    ...
} then {
    change Label to move the rect instead of resizing to accomodate drops (add an offset thing to Font)
    kill scroll velocity when hitting the edge (or rapid decel)
    make scrollfield autofit a flag
    make le scrollfield check threshold itself and only count directions it can actually scroll
    visual sugar such as "bump glow" for scrollfields
}

unordered_roadmap {
    moar UI elements {
        checkbox
        radio box
        tabs?
        auto-layout/list boxes
        text/combo box
        slider
        progress bar
        
    }
    maybe switch drawoffset system from a stack to a pass-in
    moar utility stuff in Vector2 and VRect {
        -
    }
    tween system
    figure out theme layout and fallback system
    maybe a few further refinements to bitmap fonts
    ...
    use ctrulib sync features for WorkerThread instead of spinlocks at some point
    - http://smealum.github.io/ctrulib/synchronization_8h.html#a9fe83ca3ec3c6ae269203acf367ad5a9
    duck l'orange
    
    ... tweenable drawable format?
    figure out the whole font y offset deal
}

theme layout {
    sdmc:/.starlight/themes/<name>/ {
        fonts {
            default.12.json/png/border.png
            default.16
            mono.12/16
        }
        controls {
            button.idle/pressed
            ...
        }
    }
}


drawable, drawcontext, gfxmanager (pushContext, popContext) (done mostly)
ThemeRef (done) {
    theme-asset-specific reference so themes can be reloaded
    -> operator overloaded etc.
}
T H E M E S

configurator for ui elements? maybe crtp after all
noap, macro/include shenanigans
new Button().at(40, 40).within(container).ofSize(64, 32).withText("Popsicles!");
shelved for now because shared_from_this is kind of dumb for what I need it for :D :D :D
(though maybe some trickery with putting the last-created-element in a static, combined with static factory pattern...)

maybe LoosePtr (wraps weak_ptr for expired check but references by raw pointer)
implement this to replace weak_ptr parent if it ends up impacting performance too much

maybe implement this: https://probablydance.com/2013/01/13/a-faster-implementation-of-stdfunction/

// notes {
    bitmap font converter - https://github.com/playcanvas/fonts/blob/master/fnt_to_json.py
}
